{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to swag documentation.","text":""},{"location":"#what-is-a-swag-framework","title":"What is a swag framework?","text":"<p>It's an ideology. The ideology of manual control, the ideology of extensibility. Swag is a minimalistic framework. It has no dependencies except for one - Python.</p> <p>Swag currently does not support such cool things as:</p> <ul> <li>HTTPS</li> <li>async</li> <li>path queries such as ?value=69</li> </ul> <p>But, it does support HTTP, and placeholders for routes.</p>"},{"location":"#anyway-lets-go","title":"Anyway, let's go!","text":"<p>(but keep in mind that this framework dont done at this moment, and not production ready, you can use it for play with sockets and http)</p>"},{"location":"framework-or-lib/","title":"Is that package a framework or a library?","text":"<p>I'd rather say it's a library, and a lightweight one at that. But people love the word \"framework\" for some reason. That's all</p>"},{"location":"get-started/","title":"Get started","text":""},{"location":"get-started/#here-the-simple-hello-world-app-written-in-swag","title":"Here the simple <code>Hello, world!</code> app written in swag:","text":"<pre><code>from swag.app.app import SwagApp\nfrom swag.app.config import SwagAppConfig\nfrom swag.http.response import HTTPResponse\nfrom swag.http.request import HTTPRequest\n\n\nmy_config = SwagAppConfig(port=6969, host=\"0.0.0.0\")\napp = SwagApp(config=my_config)\n\n@app.route(\"GET\", \"/hello/{world}\")\ndef hello(request: HTTPRequest, world: str):\n    return HTTPResponse(\n        f\"\"\"\n&lt;h1&gt;Hello {world}!&lt;/h1&gt;\n\"\"\".strip(),\n        content_type=\"text/html\")\n</code></pre> <p>Firstly, we just specify the <code>configuration</code> of our application, it's really simple.</p> <p>And after run that, we can see on http://0.0.0.0:6969/hello/swag <pre><code>&lt;h1&gt;Hello, swag!&lt;/h1&gt;\n</code></pre></p>"},{"location":"get-started/#the-first-thing-that-you-need-to-know","title":"The first thing that you need to know:","text":"<p>IF YOU WANT TO CREATE A PLACEHOLDER IN THE PATH (like <code>world: str</code> in this example), YOU NEED TO EXPLICITLY SPECIFY ITS TYPE.</p> <p>Available types:</p> <ul> <li>str</li> <li>int</li> <li>float</li> </ul>"},{"location":"get-started/#and-the-second-thing","title":"And the second thing:","text":"<p>It is not necessary to specify the type of the first argument passed, you can usually call it <code>request</code> and it is passed automatically. Always.</p>"},{"location":"get-started/#run-it","title":"Run it","text":"<p>You dont need other packages like unicorn, gunicorn, or even nginx.</p> <p>Just run in your shell: <code>python main.py</code></p>"},{"location":"http-method/","title":"HTTPMethod","text":"<p><code>swag.abstractions.methods</code> HTTPMethod is a union of all available http methods. It's just a str, with one of the possible values: \"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\".</p> <p>I think the best explanation is the source code:</p> <pre><code>HTTPGetMethod = Type[\"GET\"]\nHTTPPostMethod = Type[\"POST\"]\nHTTPPutMethod = Type[\"PUT\"]\nHTTPDeleteMethod = Type[\"DELETE\"]\nHTTPPatchMethod = Type[\"PATCH\"]\nHTTPOptionsMethod = Type[\"OPTIONS\"]\nHTTPHeadMethod = Type[\"HEAD\"]\n\n\nHTTPMethod = Union[\n    HTTPPostMethod,  HTTPGetMethod,\n    HTTPPutMethod, HTTPDeleteMethod,\n    HTTPPatchMethod, HTTPOptionsMethod,\n    HTTPHeadMethod]\n</code></pre> <p>Note that you can use two different ways to define a method in app.route, with string like \"GET\", and with HTTPGetMethod: <pre><code>@app.route(\"GET\", \"/hello/{world}\")\n</code></pre></p> <pre><code>@app.route(HTTPGetMethod, \"/hello/{world}\")\n</code></pre> <p>In any case, you can use what is more convenient for you. This will not affect the server response speed.</p>"},{"location":"http-request/","title":"HTTPRequest","text":"<p>HTTPRequest is a first argument that you endpoints must have. HTTPRequest is a converted data that swag collect from socket response.</p> <p><pre><code>HTTPRequest.from_string(raw_string: str, ip: int) -&gt; HTTPRequest\n</code></pre> Returns the <code>HTTPRequest</code> itself. You probably won't need to use this static method directly.</p> <pre><code>HTTPRequest.method: HTTPMethod\nHTTPRequest.headers: Dict[str, str]\nHTTPRequest.route: str\nHTTPRequest.ip: Tuple[str, int]\n</code></pre> <p>.method - request method. You don't manage the requests by endpoints in Swag, maybe i'll remove this field, because you really know which method handles that endpoint.</p> <p>.headers - parsed HTTP headers</p> <p>.route - string path, like <code>/hello/swag</code></p> <p>.ip - actually its a ip and port where did the request come from</p>"},{"location":"http-response/","title":"Response","text":"<p><code>swag.http.response.response.HTTPResponse</code> <pre><code>.extra_headers: Union[Dict[str, str], None]\n.date: Union[str, None] = None\n.content_length: Union[int, None]\n.content_type: str\n.content_data: Union[str, bytes]\n.status: int\n.message: str\n.server: str\n.package() -&gt; bytes\n</code></pre></p> <p><code>extra_headers</code> - additional headers, except Date, Server, Content-Type, Content-Length, Connection.</p> <p><code>content_length</code> - length of a data.</p> <p><code>date</code> - value for Date http header. By default is current datetime.</p> <p><code>content_type</code> - value for Content-Type header, like <code>text/html</code> or <code>application/json</code>.</p> <p><code>content_data</code> - data that swag send in the body of the server response.</p> <p><code>status</code> - http response status, like 200 or 500. By default is 200</p> <p><code>message</code> - http message for client, like \"Not Found\", \"OK\", \"Continue\".</p> <p><code>server</code> - value for Server http header. By default is <code>\"SwagServer\"</code></p> <p><code>__init__()</code></p> <p><code>package()</code> - method that return bytes to be send over the socket.</p> <p>A class that should always be returned from the endpoint. Any endpoint must return this class, or to be more precise,  BaseResponse with a specific package method that returns bytes.</p>"}]}